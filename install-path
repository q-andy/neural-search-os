#!/usr/bin/env python3

# Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License").
# You may not use this file except in compliance with the License.
# A copy of the License is located at
#
# http://aws.amazon.com/apache2.0/
#
# or in the "LICENSE.txt" file accompanying this file.
# This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
# CONDITIONS OF ANY KIND, express or implied. See the License for the
# specific language governing permissions and # limitations under the License.

import argparse
import getpass
import logging
import os
import platform
import re
import shutil
import subprocess as sub
import sys
import tempfile
import time
import webbrowser


DCV_CONNECT_SCRIPT = "/usr/libexec/dcvcddconnect.sh"
DCV_GET_DIAGNOSTICS_SCRIPT = "/usr/libexec/dcvcddgetdiagnostics.py"

DIAGNOSTICS_DIR = "diagnostics"

VERSION = "0.9.2"

PYTHON_MIN_VERSION_MAJOR = 3
PYTHON_MIN_VERSION_MINOR = 6

HELP = f'''
Connect to a remote DCV Cloud Developer Desktop.

This script creates a connection with the cloud dev desktop using the
{DCV_CONNECT_SCRIPT} installed in the server, and perform one of several
operations depending on the command.

The supported commands are:
* close-session: close the existing session on the cloud dev desktop
* connect: create a connection if needed, and connect to the session using
  either a native or a web client
* create-session: create a session on the cloud dev desktop
* get-diagnostics: fetch a zip file containing diagnostic files of the cloud dev
  desktop
* restart-services: restart the dcv services on the cloud dev desktop
* share: provide a link which can be used to connect to an already created
  session

This script requires Python >= {PYTHON_MIN_VERSION_MAJOR}.{PYTHON_MIN_VERSION_MINOR}.

This script version is {VERSION}.
'''

PROMPT = "cdd"

WSSH_DEFAULT_LOCAL_PORTS_INTERVAL = "7443+10"

log = logging.getLogger("dcv-cdd")
log_handler = logging.StreamHandler()
log.addHandler(log_handler)
log.setLevel(logging.INFO)


def set_log_topics(topics=None):
    prompt = PROMPT
    if topics:
        prompt += "/" + "/".join(topics)
    log_handler.setFormatter(logging.Formatter(f'{prompt}> %(levelname)s: %(message)s'))


SESSION_TOKEN_EXPIRE_SECONDS = 30
GUEST_SESSION_TOKEN_EXPIRE_SECONDS = 120
WSSH_TUNNEL_MAX_CONNECTION_ATTEMPTS = 60


INTERVAL_SPEC_HELP = "START:END or START+COUNT with START, END, and COUNT as integers"


def parse_interval(interval):
    match = re.match(r'^(?P<start>[0-9]+)((?P<end>:[0-9]+)|(?P<count>\+[0-9]+))$', interval)
    if not match:
        raise Exception(f"Invalid interval '{interval}', must be in the format '{INTERVAL_SPEC_HELP}")

    start = int(match.group('start'))
    if match.group('end'):
        end = int(match.group('end')[1:])
    elif match.groups('count'):
        end = start + int(match.group('count')[1:])
    else:
        raise Exception(f"Invalid interval '{interval}', missing end or count")

    if end < start:
        raise Exception(f"Invalid interval '{interval}', end value '{end}' must be >= '{start}'")

    log.debug(f"Interval '{interval}' parsed as start:{start} end:{end}")
    return start, end - start


def _check_command_output(cmd):
    env = os.environ
    if re.match("^MSYS_NT.*", platform.system()):
        # disable path expansion on MSYS/MSYS2
        env['MSYS2_ARG_CONV_EXCL'] = '*'
        env['MSYS_NO_PATHCONV'] = '1'

    process = sub.run(cmd, shell=True, universal_newlines=True, check=True, stdout=sub.PIPE, stderr=sub.PIPE, env=env)

    std_err = process.stderr.strip()
    std_out = process.stdout.strip()

    # Print on stderr without prompt
    if std_err:
        sys.stderr.write(f"{std_err}\n")

    if std_out:
        log.debug(f'The result of the command was:\n"{std_out}"')

    return (std_out, std_err)


def error(message, fail_on_error=True):
    log.error(message)
    if fail_on_error:
        sys.exit(1)


def check_version(server_version, instance, user, ssh_command):
    """Compare the script version with the provided version, if it's lower print a warning."""
    server_version_list = server_version.split(".")
    current_version_list = VERSION.split(".")
    server = (server_version_list[0], server_version_list[1], server_version_list[2])
    current = (current_version_list[0], current_version_list[1], current_version_list[2])
    if server > current:
        path = os.path.realpath(__file__)
        remote_path = '/usr/share/dcv/cdd/dcv-cdd.py'
        scp_tool = 'pscp' if 'plink' in ssh_command else 'scp'
        update_command = f"{scp_tool} {user}@{instance}:{remote_path} {path}\n"
        log.warning(f"Client script version is {VERSION} but a later version {server_version} is available on the server.\n"
                    f"Please update the client script using the following or equivalent command:\n{update_command}")


def _get_native_default_path():
    path = None
    try:
        # Check if dcvviewer is in the path
        path = "dcvviewer"
        cmd = path + " --version"
        log.debug(f"Checking the viewer command '{cmd}'...")
        sub.check_output(cmd, shell=True, stderr=sub.STDOUT)
    except Exception:
        # Check if it is in a standard location
        local_sys = platform.system()

        if local_sys == "Windows":
            path = "C:\\Program Files (x86)\\NICE\\DCV\\Client\\bin\\dcvviewer.exe"
        elif re.match("^MSYS_NT.*", local_sys):
            # MSYS
            path = "/c/Program Files (x86)/NICE/DCV/Client/bin/dcvviewer.exe"
        elif local_sys == "Linux":
            path = "/usr/bin/dcvviewer"
        elif local_sys == "Darwin":
            # Mac OsX
            path = "/Applications/DCV Viewer.app/Contents/MacOS/dcvviewer"
        else:
            log.warning(f"Unknown system {local_sys}, cannot find a path for the viewer")
            path = None

        if path:
            try:
                cmd = f"\"{path}\" --version"
                log.debug(f"Checking the viewer command '{cmd}'...")
                sub.check_output(cmd, shell=True, stderr=sub.STDOUT)
            except Exception:
                log.warning("Could not find the viewer in the system")
                path = None

    if path:
        log.info(f"Found viewer with path '{path}'")
    return path


def _get_ssh_command(ssh_tool):
    if ssh_tool == 'auto':
        import psutil

        log.debug("Detecting SSH tool to use...")

        if platform.system() == "Windows" and not sys.maxsize > 2**32:
            # see https://github.com/giampaolo/psutil/issues/1264
            error(f"The used Python executable {sys.executable} is 32 bit, but this script needs Python 64 bit to work correctly with psutil on Windows.\nSwitch to Python 64 bit or specify the SSH tool to use with --ssh-tool.")

        if 'pageant.exe' in (p.name() for p in psutil.process_iter()) and shutil.which('plink'):
            ssh_tool = 'plink'
        else:
            ssh_tool = 'ssh'

    if not shutil.which(ssh_tool):
        error(f"No {ssh_tool} tool found in PATH, cannot connect to the remote developer desktop")

    ssh_command = ssh_tool + ' -batch' if ssh_tool == 'plink' else ssh_tool

    return ssh_command


def _run_ssh_script(ssh_command, user, instance, script, script_args=''):

    try:
        script_command = script if not script_args else f"{script} {script_args}"
        cmd = f'{ssh_command} {user}@{instance} "{script_command}"'
        log.debug(f"Launching SSH command:\n{cmd}")
        out, err = _check_command_output(cmd)

        # At first ssh connection, the ssh command alerts it is adding the host to the known hosts list
        if re.search("Permanently added .* to the list of known hosts.", err):
            out, err = _check_command_output(cmd)

    except sub.CalledProcessError as e:
        hint = ''
        while True:
            err_str = e.stderr.strip()
            out_str = e.stdout.strip()
            if re.match(f".*{script}: No such file or directory", err_str):
                hint = \
                    f"The script '{script}' seems missing on the server.\n" \
                    "Check if the DCV server is installed on your Cloud Developer Desktop"
                break

            if re.match(r".*Permission denied \(publickey\)", err_str) or \
               re.match(r".*No supported authentication methods available \(server sent: publickey\)", err_str):

                if ssh_command.startswith("plink"):
                    midway_command = "make sure you run pageant with an updated cert file. For more detailed information, check:\nhttps://w.amazon.com/bin/view/NextGenMidway/UserGuide/WindowsSetup#HConfiguringPuTTYwithMidway"
                else:
                    if re.match("^MSYS_NT.*", platform.system()):
                        midway_command = "launch the following command from terminal: start mwinit"
                    else:
                        midway_command = "launch the following command from terminal: mwinit"

                hint = \
                    "It looks like you are missing permissions to connect, make sure you initialized Midway.\n" \
                    f"To initialize Midway, {midway_command}"
                break
            break

        suffix = ''
        if err_str:
            suffix = 'with error:\n"{err_msg}"'.format(err_msg='\n'.join(filter(None, [err_str, hint])))
        elif out_str:
            suffix = f'with output:\n"{out_str}"'
        error(f'"{script}" failed {suffix}')

    return out


def _parse_message(data, fields_formats, fields_formats_separator):

    res = {}
    full_format = fields_formats_separator.join(fields_formats.values())
    match = re.search(full_format, data)
    if match:
        keys = list(fields_formats.keys())
        values = match.groups()
        res = {keys[i]: values[i] for i in range(len(keys))}

    return res


def run_connect_command(ssh_command, user, instance, connect_args=''):

    output = _run_ssh_script(ssh_command, user, instance, DCV_CONNECT_SCRIPT, connect_args)

    while True:
        fields_formats = {
            "port": r"DcvServerPort=([\d]+)",
            "session_id": r"DcvSessionId=([\w]+)",
            "token": r"DcvSessionToken=([\w-]+)",
            "server_script_version": r"DcvClientScriptVersion=([\d]+[.][\d]+[.][\d]+)",
            "server_installed_version": r"DcvServerInstalled=([\d]+[.][\d]+[-][\d]+)",
            "server_running_version": r"DcvServerRunning=([\d]+[.][\d]+[-][\d]+)"
        }

        res = _parse_message(output, fields_formats, r" ")
        if res:
            break

        fields_formats = {
            "port": r"DcvServerPort=([\d]+)",
            "session_id": r"DcvSessionId=([\w]+)",
            "token": r"DcvSessionToken=([\w-]+)",
            "server_script_version": r"DcvClientScriptVersion=([\d]+[.][\d]+[.][\d]+)"
        }

        res = _parse_message(output, fields_formats, r" ")
        if res:
            break

        fields_formats = {
            "server_script_version": r"DcvClientScriptVersion=([\d]+[.][\d]+[.][\d]+)",
            "message": r"(.*)"
        }

        res = _parse_message(output, fields_formats, r"\n")
        if res:
            break

        fields_formats = {
            "message": r"(.*)"
        }

        res = _parse_message(output, fields_formats, r"")
        if res:
            break

    if 'server_script_version' in res:
        check_version(res['server_script_version'], instance, user, ssh_command)

    log.debug(f"Received response from connection command:\n{res}")
    if 'message' in res:
        log.info(f"Received message from instance {args.instance}:\n{res['message']}")

    if 'server_installed_version' in res:
        if res['server_installed_version'] != res['server_running_version']:
            log.info(f"DCV Server installed version ({res['server_installed_version']}) differs from running version ({res['server_running_version']}). Please consider restarting DCV Server service.")

    return res


def run_get_diagnostics_command(ssh_command, user, instance, dest_dir, debug):

    log.info("Fetching diagnostics...")
    script_args = "--debug" if debug else ""
    output = _run_ssh_script(ssh_command, user, instance, DCV_GET_DIAGNOSTICS_SCRIPT, script_args)

    fields_formats = {
        "diagnostics_version": r"DcvDiagnosticsVersion=([\d]+[.][\d]+[.][\d]+)",
        "diagnostics_path": r"DcvDiagnosticsPath=(.*[.]zip)"
    }

    res = _parse_message(output, fields_formats, r" ")

    log.debug(f"Received response from get diagnostics script:\n{res}")
    if 'message' in res:
        log.info(f"Received message from instance {args.instance}:\n{res['message']}")

    if 'diagnostics_path' not in res:
        return

    remote_path = res['diagnostics_path']

    if not dest_dir:
        dest_dir = tempfile.mkdtemp()
    else:
        os.makedirs(dest_dir, exist_ok=True)

    scp_tool = 'pscp' if ssh_command.startswith('plink') else 'scp'
    cmd = f"{scp_tool} {user}@{instance}:{remote_path} {dest_dir}"
    out, err = _check_command_output(cmd)

    output = _run_ssh_script(ssh_command, user, instance, f"rm {remote_path}")

    archive_path = os.path.join(dest_dir, os.path.basename(remote_path))
    log.info(f"Diagnostics saved to {archive_path}")

    return res


def run_restart_services_command(ssh_command, user, instance):
    log.info("Restarting DCV services...")

    for service in ['dcvserver', 'dcvcddextauth']:
        _run_ssh_script(ssh_command, user, instance, f"sudo systemctl stop {service}")

    for service in ['dcvcddextauth', 'dcvserver']:
        for op in ['start', 'is-active']:
            _run_ssh_script(ssh_command, user, instance, f"sudo systemctl {op} {service}")

    log.info("DCV services restarted successfully")


def _add_shared_args(parser):
    current_user = getpass.getuser()

    # Mandatory
    parser.add_argument("instance", help="specify the instance address you want to connect to")

    # Other optional arguments
    parser.add_argument("--user", "-u", default=current_user,
                        help=f"specify the username for the connection (default: {current_user})")

    if re.match("^(MSYS_NT|Windows).*", platform.system()):
        ssh_choices = ["ssh", "plink"]
        if re.match("^MSYS_NT.*", platform.system()):
            default_ssh_tool = 'ssh'
        else:
            default_ssh_tool = 'auto'
            ssh_choices += ['auto']  # psutil used to audo-detect cannot be installed on MSYS
        help = "Only for Windows, optional - Use it only if you want to specify the SSH tool to be used: " + \
               f"use 'plink' if you configured PuTTY with Midway or 'ssh' if you configured OpenSSH with Midway (default: {default_ssh_tool})"
    else:
        ssh_choices = ["ssh"]
        default_ssh_tool = 'ssh'
        help = argparse.SUPPRESS

    parser.add_argument("--ssh-tool", choices=ssh_choices, default=default_ssh_tool, help=help)
    # https://sim.amazon.com/issues/PLANK-235
    parser.add_argument("--ssh-instance", help="specify the target SSH instance when different from the DCV server instance")


def _check_port_used(port):
    import socket
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        return s.connect_ex(('localhost', port)) == 0


def _check_port_reusable_for_ssh_tunnel(target_host, local_port, remote_port):
    log.debug(f"Checking if port '{local_port}' can be reused to establish an SSH tunnel to '{target_host}:{remote_port}'...")
    if platform.system() == 'Windows':
        is_current_dev_dsk = False
        try:
            import psutil
            for proc in psutil.process_iter():
                if proc.name() == 'ssh.exe':
                    ssh_process_full_command = ' '.join(proc.cmdline())
                    is_current_dev_dsk = f'{local_port}:localhost:{remote_port} {target_host}' in ssh_process_full_command
        except Exception as e:
            log.warning(f'Got error when checking if current port can be reused: {e}')
    else:
        check_tunnel_command = f"ps aux | grep '{local_port}:localhost:{remote_port} {target_host}' | grep -v grep"
        is_current_dev_dsk = os.system(check_tunnel_command) == 0

    return is_current_dev_dsk


def create_ssh_tunnel(
    *, ssh_instance, local_ports_start, local_ports_count, remote_port,
    reuse_ssh_tunnel=False
):
    log.info(f"Creating SSH tunnel from localhost:{local_ports_start}+{local_ports_count} to {ssh_instance}:{remote_port}...")
    ssh_tunnel = None
    success = False

    for local_port in range(local_ports_start, local_ports_start + local_ports_count):
        log.info(f'Checking if port {local_port} on localhost is already in use...')
        if _check_port_used(local_port):
            if reuse_ssh_tunnel and _check_port_reusable_for_ssh_tunnel(ssh_instance, local_port, remote_port):
                log.info(f'Reusing existing opened SSH tunnel on port {local_port}...')
                success = True
                break
            else:
                log.info(f'Port {local_port} is currently used by another program, proceeding to try next available port...')
        else:
            log.info(f'SSH tunnel not established yet, starting an SSH tunnel from {ssh_instance}:{remote_port} to localhost:{local_port}...')
            ssh_tunnel = sub.Popen(['ssh', '-N', '-L', f'{local_port}:localhost:{remote_port}', ssh_instance])
            success = True
            break

    if not success:
        error(f'Failed to establish an SSH tunnel for WSSH to use: all ports between {local_ports_start} and {local_ports_start + local_ports_count} are occupied. Please stop the process that occupies any of the ports, then retry.')

    return ssh_tunnel, local_port


def connect(
    *, ssh_tool, user, ssh_instance, detach, forced_detach,
    wssh, wssh_local_ports_interval, wssh_reuse_ssh_tunnel,
    instance, native, native_path=None, native_extra_args=None, web=False
):
    log.debug(f"Connecting to CDD with arguments {locals()}...")

    if wssh_local_ports_interval:
        wssh = True
    if wssh:
        if not wssh_local_ports_interval:
            wssh_local_ports_interval = WSSH_DEFAULT_LOCAL_PORTS_INTERVAL
        wssh_local_ports_start, wssh_local_ports_count = parse_interval(wssh_local_ports_interval)
        if wssh_local_ports_count < 1:
            error(f"Invalid WSSH local ports interval '{wssh_local_ports_interval}' specified, local ports count must be >= 1")

    log.info("Connecting to session...")
    res = run_connect_command(_get_ssh_command(ssh_tool), user, ssh_instance, "connect")

    for param in ['port', 'token', 'session_id']:
        if param not in res:
            error(f"Failed to get connection information for parameter '{param}' from server")

    if wssh:
        instance = 'localhost'
        remote_port = res['port']
        # defaulting to nodetach mode when --wssh flag is added; if users have specified a
        # --detach flag when calling the script, the flag will be honored
        if not forced_detach:
            detach = False
            log.info('--wssh flag added, defaulting to nodetach mode')

        wssh_tunnel, port = create_ssh_tunnel(
            ssh_instance=ssh_instance, remote_port=remote_port,
            local_ports_start=wssh_local_ports_start,
            local_ports_count=wssh_local_ports_count,
            reuse_ssh_tunnel=wssh_reuse_ssh_tunnel
        )
        if wssh_tunnel:
            # if we just created the SSH tunnel, wait until the tunnel has been
            # successfully opened
            import ssl
            import urllib.request
            ssl_context = ssl._create_unverified_context()
            for _ in range(WSSH_TUNNEL_MAX_CONNECTION_ATTEMPTS):
                try:
                    urllib.request.urlopen(
                        f'https://localhost:{port}/version', context=ssl_context
                    ).close()
                    log.info("SSH tunnel established")
                    break
                except Exception:
                    pass
                time.sleep(1)
            else:
                log.warning("SSH tunnel still not established, continuing anyway...")
    else:
        port = res['port']
    token = res['token']
    session_id = res['session_id']

    if native:
        if native_path is None:
            native_path = _get_native_default_path()
            if native_path is None:
                error("No native client found in default paths.\n" +
                      "Try specifing a path with the -p option or use the web client.")
    elif not native and not web:
        native_path = _get_native_default_path()
        if native_path:
            native = True
        else:
            log.info("No DCV native client found in default path, using the web client.")

    if native:
        try:
            auth_args = f"\"dcv://{instance}:{port}#{session_id}\" --auth-token={token}"
            misc_args = ' '.join(native_extra_args)
            if detach:
                if platform.system() == 'Darwin':
                    cmd = f"open --new -a \"{native_path}\" --args {misc_args} {auth_args}"
                elif platform.system() == 'Windows':
                    cmd = f"start \"dcvviewer\" \"{native_path}\" {misc_args} {auth_args}"
                else:  # Linux or MSYS
                    cmd = f"'{native_path}' {misc_args} {auth_args} &"
            else:
                cmd = f"\"{native_path}\" {misc_args} {auth_args}"

            log.info(f"Launching command in {'' if detach else 'no'}detached mode:\n{cmd}")
            sub.check_call(cmd, shell=True, stderr=sub.STDOUT)
            if wssh and not detach and wssh_tunnel:
                log.info(f"Client is closed, terminating the SSH tunnel at PID {wssh_tunnel.pid}...")
                if platform.system() == 'Windows':
                    # using TASKKILL to make sure both parent (ssh.exe) and child (wssh.exe) processes are killed
                    sub.check_call(f'TASKKILL /F /PID {wssh_tunnel.pid} /T')
                else:
                    wssh_tunnel.terminate()
                log.info('SSH tunnel terminated, and your session has ended.')
        except sub.CalledProcessError as e:
            error(f"Failed to launch the '{native_path}' client: {e}")
    else:  # web client
        if not detach:
            log.warning("--nodetach was specified, but it is ignored with the web client")
        url = f"https://{instance}:{port}?authToken={token}#{session_id}"
        try:
            log.debug(f"Launching webbrowser with URL '{url}'")
            if not webbrowser.open_new(url):
                raise webbrowser.Error("Unsupported system")
        except webbrowser.Error as e:
            log.warning(f"Unable to open the web browser: {e}")
            log.info(f"Please use the following one-time URL in your browser within {SESSION_TOKEN_EXPIRE_SECONDS} seconds:\n{url}")


class Formatter(argparse.ArgumentDefaultsHelpFormatter, argparse.RawDescriptionHelpFormatter):
    pass


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description=HELP, formatter_class=Formatter)
    subparsers = parser.add_subparsers(title="command", help="command to be executed remotely, use 'dcv-cdd.py COMMAND_NAME --help' for more usage details", dest="command")

    connect_parser = subparsers.add_parser("connect")

    detach_connect_group = connect_parser.add_mutually_exclusive_group()
    detach_connect_group.add_argument("--detach", action="store_true", default=True,
                                      help="detach the native client from the terminal after launching it - deprecated, use --notdetach to disable it")
    detach_connect_group.add_argument("--nodetach", "-D", action="store_false", dest='detach',
                                      help="do not detach the native client from the terminal after launching it")

    _add_shared_args(connect_parser)
    connect_group = connect_parser.add_mutually_exclusive_group()
    connect_group.add_argument("--native", "-n", action="store_true",
                               help="use the native client, search the dcvviewer in path or in the standard path")
    connect_group.add_argument("--path", "-p", type=str,
                               metavar="dcvviewer_path",
                               help="force the use of the native client and pass the path of client executable dcvviewer")
    connect_group.add_argument("--web", "-w", action="store_true",
                               help="use the web client (call the default browser)")
    connect_parser.add_argument('native_extra_args', nargs="*", help="specify options to pass to the native client")
    connect_parser.add_argument("--wssh", "-W", default=False, action="store_true",
                                help="use WSSH to connect to cloud developer desktop off-VPN")
    connect_parser.add_argument("--wssh-local-ports-interval", "-L", default=None,
                                help=f"define local ports interval to use for WSSH connection in the format {INTERVAL_SPEC_HELP}, if not specified assume '{WSSH_DEFAULT_LOCAL_PORTS_INTERVAL}'")
    connect_parser.add_argument("--wssh-disable-reuse-ssh-tunnel", action='store_true',
                                help="disable checking and reusing an SSH tunnel port if it was already used by WSSH")

    share_parser = subparsers.add_parser("share")
    _add_shared_args(share_parser)
    share_group = share_parser.add_mutually_exclusive_group(required=True)
    share_group.add_argument("--get-token", type=str, metavar="GUESTNAME", dest="get_token_guest",
                             help="one time URL for session access")
    share_group.add_argument("--remove", metavar="GUESTNAME", dest="remove_guest",
                             help="revoke the permission of a guest")
    share_group.add_argument("--update", metavar="GUESTNAME", dest="update_guest",
                             help="Update permissions of a guest")
    share_group.add_argument("--list", action="store_true", dest="list_guests",
                             help="list all guests with access permissions to session")
    # --mode has "viewer" as default value, this default value is defined in the external authenticator dcvcddextauth.py and not here
    share_parser.add_argument("--mode", metavar="PERMISSIONS",
                              help="guest permissions mode (can be 'viewer' or 'full_access')")

    _add_shared_args(subparsers.add_parser("create-session"))
    _add_shared_args(subparsers.add_parser("close-session"))

    get_diagnostics_parser = subparsers.add_parser("get-diagnostics")
    get_diagnostics_parser.add_argument("--dest-dir", help="destination path for the log dump", required=False)
    _add_shared_args(get_diagnostics_parser)

    restart_parser = subparsers.add_parser("restart-services")
    _add_shared_args(restart_parser)

    help_parser = subparsers.add_parser("help")
    help_parser.add_argument("command_name", nargs="?", help='show help for the specified command')

    # Version
    parser.add_argument("--version", action="version",
                        version="{prog}s {version}".format(prog="%(prog)", version=VERSION))

    parser.add_argument("--debug", "-d", default=False, action="store_true",
                        help="set the debug level to debug")

    args = parser.parse_args()
    if args.command == "connect" and args.path:
        args.native = True

    if args.debug:
        log.setLevel(logging.DEBUG)

    # needed because the subparser required parameter is broken with Python <3.7:
    # https://github.com/python/cpython/pull/3027
    if not args.command:
        error("The command argument is required")

    pyver = sys.version_info
    if (pyver.major, pyver.minor) < (PYTHON_MIN_VERSION_MAJOR, PYTHON_MIN_VERSION_MINOR):
        error(f"You are running python version {pyver.major}.{pyver.minor} but at least version {PYTHON_MIN_VERSION_MAJOR}.{PYTHON_MIN_VERSION_MINOR} is required")

    log.debug(f"Running {os.path.basename(__file__)} version {VERSION}")

    def _match_command(command):
        if not args.command == command:
            return False

        topics = [args.command]
        set_log_topics(topics)
        return True

    if hasattr(args, 'ssh_instance'):
        ssh_instance = args.ssh_instance if args.ssh_instance else args.instance

    if _match_command('share'):
        log.info("Sharing session...")
        connect_args = args.command
        if args.get_token_guest:
            connect_args += " getTokenGuest " + args.get_token_guest
        elif args.remove_guest:
            connect_args += " removeGuest " + args.remove_guest
        elif args.update_guest:
            connect_args += " updateGuest " + args.update_guest
        elif args.list_guests:
            connect_args += " listGuests"

        if args.mode:
            connect_args += " " + args.mode

        res = run_connect_command(_get_ssh_command(args.ssh_tool), args.user, ssh_instance, connect_args)
        if args.get_token_guest:
            url = f"https://{args.instance}:{res['port']}?authToken={res['token']}#{res['session_id']}"
            log.info(f"Please use the following one-time URL in your browser within {GUEST_SESSION_TOKEN_EXPIRE_SECONDS} seconds:\n{url}")

    elif _match_command('connect'):
        connect(
            ssh_tool=args.ssh_tool, user=args.user, ssh_instance=ssh_instance,
            instance=args.instance, detach=args.detach, forced_detach=('--detach' in sys.argv),
            wssh=args.wssh, wssh_local_ports_interval=args.wssh_local_ports_interval,
            wssh_reuse_ssh_tunnel=(not args.wssh_disable_reuse_ssh_tunnel),
            web=args.web,
            native=args.native, native_path=args.path, native_extra_args=args.native_extra_args
        )

    elif _match_command('create-session') or _match_command('close-session'):
        verb = "Creating" if args.command == "create-session" else "Closing"
        log.info(f"{verb} session...")
        res = run_connect_command(_get_ssh_command(args.ssh_tool), args.user, ssh_instance, args.command)

    elif _match_command('get-diagnostics'):
        res = run_get_diagnostics_command(_get_ssh_command(args.ssh_tool), args.user, ssh_instance, args.dest_dir, args.debug)

    elif _match_command('restart-services'):
        res = run_restart_services_command(_get_ssh_command(args.ssh_tool), args.user, ssh_instance)

    elif _match_command('help'):
        if args.command_name:
            subparsers.choices[args.command_name].print_help()
        else:
            print(HELP)
